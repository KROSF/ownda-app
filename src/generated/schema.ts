/* THIS IS A GENERATED FILE - DO NOT MODIFY */
export type Maybe<T> = T | null | undefined;
export type InputMaybe<T> = T | null | undefined;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: string;
};

export type Account = {
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  name: Scalars['String'];
  transactions: Array<Transaction>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type Category = {
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  name: Scalars['String'];
  parent?: Maybe<Category>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type Credential = {
  accessToken: Scalars['String'];
  client: Scalars['String'];
  expiry: Scalars['Int'];
  tokenType: Scalars['String'];
  uid: Scalars['String'];
};

export type Mutation = {
  refreshToken?: Maybe<RefreshTokenPayload>;
  userConfirmRegistrationWithToken?: Maybe<UserConfirmRegistrationWithTokenPayload>;
  userLogin?: Maybe<UserLoginPayload>;
  userLogout?: Maybe<UserLogoutPayload>;
  userRegister?: Maybe<UserRegisterPayload>;
  userResendConfirmationWithToken?: Maybe<UserResendConfirmationWithTokenPayload>;
  userSendPasswordResetWithToken?: Maybe<UserSendPasswordResetWithTokenPayload>;
  userUpdatePasswordWithToken?: Maybe<UserUpdatePasswordWithTokenPayload>;
};

export type MutationRefreshTokenArgs = {
  input: RefreshTokenInput;
};

export type MutationUserConfirmRegistrationWithTokenArgs = {
  confirmationToken: Scalars['String'];
};

export type MutationUserLoginArgs = {
  email: Scalars['String'];
  password: Scalars['String'];
};

export type MutationUserRegisterArgs = {
  confirmUrl?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
  password: Scalars['String'];
  passwordConfirmation: Scalars['String'];
};

export type MutationUserResendConfirmationWithTokenArgs = {
  confirmUrl: Scalars['String'];
  email: Scalars['String'];
};

export type MutationUserSendPasswordResetWithTokenArgs = {
  email: Scalars['String'];
  redirectUrl: Scalars['String'];
};

export type MutationUserUpdatePasswordWithTokenArgs = {
  password: Scalars['String'];
  passwordConfirmation: Scalars['String'];
  resetPasswordToken: Scalars['String'];
};

export type Query = {
  /** Categories of transactions */
  categories: Array<Category>;
  /** Current user */
  me: User;
};

/** Autogenerated input type of RefreshToken */
export type RefreshTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of RefreshToken */
export type RefreshTokenPayload = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  credentials: Credential;
};

export type Transaction = {
  amount: Scalars['Float'];
  category: Category;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  name: Scalars['String'];
  type: TransactionTypes;
  updatedAt: Scalars['ISO8601DateTime'];
};

export const TransactionTypes = {
  Expense: 'EXPENSE',
  Income: 'INCOME',
} as const;

export type TransactionTypes =
  typeof TransactionTypes[keyof typeof TransactionTypes];
export type User = {
  accounts: Array<Account>;
  createdAt: Scalars['ISO8601DateTime'];
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  image?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

/** Autogenerated return type of UserConfirmRegistrationWithToken */
export type UserConfirmRegistrationWithTokenPayload = {
  authenticatable: User;
  /** Authentication credentials. Null unless user is signed in after confirmation. */
  credentials?: Maybe<Credential>;
};

/** Autogenerated return type of UserLogin */
export type UserLoginPayload = {
  authenticatable: User;
  credentials: Credential;
};

/** Autogenerated return type of UserLogout */
export type UserLogoutPayload = {
  authenticatable: User;
};

/** Autogenerated return type of UserRegister */
export type UserRegisterPayload = {
  authenticatable: User;
  /** Authentication credentials. Null if after signUp resource is not active for authentication (e.g. Email confirmation required). */
  credentials?: Maybe<Credential>;
};

/** Autogenerated return type of UserResendConfirmationWithToken */
export type UserResendConfirmationWithTokenPayload = {
  message: Scalars['String'];
};

/** Autogenerated return type of UserSendPasswordResetWithToken */
export type UserSendPasswordResetWithTokenPayload = {
  message: Scalars['String'];
};

/** Autogenerated return type of UserUpdatePasswordWithToken */
export type UserUpdatePasswordWithTokenPayload = {
  authenticatable: User;
  /** Authentication credentials. Resource must be signed_in for credentials to be returned. */
  credentials?: Maybe<Credential>;
};
